# 객체지향

Patterns always have two parts: the how and the when.
- Martin Fowler의 [LocalDTO](https://martinfowler.com/bliki/LocalDTO.html)에서

## 절차지향

- 프로시저를 이용한(procedural) 프로그래밍 기법
- 데이터를 이용한 프로시저로 구성된다

### 참고

#### wikipedia > 절차적 프로그래밍

[절차적 프로그래밍](https://ko.wikipedia.org/wiki/%EC%A0%88%EC%B0%A8%EC%A0%81_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D)
- 때때로 [명령형 프로그래밍](https://ko.wikipedia.org/wiki/%EB%AA%85%EB%A0%B9%ED%98%95_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D)과 동의어로 쓰이기도 하지만, 프로시저 호출의 개념을 바탕으로 하고 있는 프로그래밍 패러다임을 의미하기도 한다. 
- 프로시저는 루틴, 하위프로그램, 서브루틴, 메서드, 함수라고도 한다.
- 간단히 말하여 수행되어야 할 연속적인 계산 과정을 포함하고 있다.

## 객체지향

### 도서 "클린 아키텍처" 중에서

OO란 무엇인가?
- 캡슐화? OO 이전에도 있었다
- 상속? OO가 만들어낸 개념은 아니지만 편하게 해주긴 한다

> "OO란 무엇인가? 이 질문에 답하기 위해 다양한 의견과 수많은 답변이 있었다. 하지만 소프트웨어 아키텍트 관점에서 정답은 명백하다. OO란 다형성을 이용하여 전체 시스템의 모든 소스 코드 의존성에 대한 절대적인 제어 권한을 획득할 수 있는 능력이다. OO를 사용하면 아키텍트는 플러그인 아키텍처를 구성할 수 있고, 이를 통해 고수준의 정책을 포함하는 모듈은 저수준의 세부사항을 포함하는 모듈에 대해 독립성을 보장할 수 있다. 저수준의 세부사항은 중요도가 낮은 플러그인 모듈로 만들 수 있고, 고수준의 정책을 포함하는 모듈과는 독립적으로 개발하고 배포할 수 있다.

### 캡슐화 

캡슐화의 결과는 내부 구현 변경의 유연성 획득

캡슐화를 위한 두 개의 규칙
- Tell, Don't Ask
- 데미테르의 법칙(Law of Demeter)
  - Tell, Don't Ask 규칙을 잘 따를 수 있도록 만들어주는 또 다른 규칙
    - 메서드에서 생성한 객체의 메소드만 호출
    - 파라미터로 받은 객체의 메서드만 호출
    - 필드로 참조하는 객체의 메서드만 호출 

#### 참고 

##### 도서 '테스트 주도 개발로 배우는 객체 지향 설계와 실천' 중에서
- '캡슐화'와 '정보은닉'은 설계의 품질을 나타내는 별개의 개념이자 서로 독립적인 설계 품질

##### 이규원님 블로그 > "캡슐화와 정보 숨김" 중에서

https://justhackem.wordpress.com/2017/02/28/encapsulation-and-information-hiding/

캡슐화의 여러가지 의미
- 정보 숨김(information hiding)과 동의어
  - 어려운 설계 결정과 변경될 가능성이 높은 설계 결정이 다른 모듈로부터 숨겨지는 것
- 구현 숨김(implementation hiding)
  - 정보 숨김의 의미
- 데이터 숨김(data hiding)과 동의어
    - 정보 숨김
    - 개체지향 프로그래밍에서 개체의 상태를 공개 노출하지 않고 접근자(속성)를 통하도록 접근 경로를 제한하는 것
- 응집을 통한 새로운 정체성 형성

## 객체 지향 설계 과정

1. 제공해야 할 기능을 찾고 또는 세분화하고, 그 기능을 알맞은 객체에 할당한다.
 - 기능을 구현하는데 필요한 데이터를 객체에 추가한다. 객체에 데이터를 먼저 추가하고 그 데이터를 이용하는 기능을 넣을 수도 있다.
 - 기능은 최대한 캡슐화해서 구현한다.
2. 객체 간에 어떻게 메시지를 주고받을 지 결정한다.
3. 과정1과 과정2를 개발하는 동안 지속적으로 반복한다.


















