# 설계 원칙: SOLID

## 책 내용 정리

### 단일 책임 원칙(Single responsibility principle)

> 클래스는 단 한 개의 책임을 가져야 한다
- 클래스를 변경하는 이유는 단 한 개여야 한다

책임을 분리하면 변경의 여파를 줄일 수 있다.

단일 책임 원칙을 어기면 재사용을 어렵게 한다.
- 사용하지 않을 패키지도 함께 가져올 수 있다.

#### 책임이란 변화에 대한 것

각각의 책임은 서로 다른 이유로 변경되고, 서로 다른 비율로 변경되는 특징이 있다.

메서드를 실행하는 것이 누구인지 확인해보기
- 클래스의 사용자들이 서로 다른 메서드들을 사용한다면 그들 메서드는 각각 다른 책임에 속할 가능성이 높고, 따라서 책임 분리 후보가 될 수 있다.

### 개방 폐쇄 원칙(Open-closed principle)

> 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다.
- 기능을 변경하거나 확장할 수 있으면서
- 그 기능을 사용하는 코드는 수정하지 않는다.

구현 방법
- 인터페이스로 분리하여, 기능을 사용하는 코드는 인터페이스에만 의존하고, 추가 기능은 인터페이스를 상속하면서 가능.
- 상속. 상속은 상위 클래스의 기능을 그대로 사용하면서 하위 클래스에서 일부 구현을 오버라이딩 할 수 있는 방법을 제공한다.

#### 개방 폐쇄 원칙이 깨질 때의 주요 증상

- 다운 캐스팅을 한다.
- 비슷한 if-else 블록이 존재한다.

#### 개방 폐쇄 원칙은 유연함에 대한 것

변화가 예상되는 것을 추상화해서 변경의 유연함을 얻도록 해준다.

### 리스코프 치환 원칙(Liskov substitution principle)

> 상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 한다

#### 리스코프 치환 원칙을 지키지 않을 때의 문제

1. 직사각형-정사각형의 문제
- https://en.wikipedia.org/wiki/Circle%E2%80%93ellipse_problem

2. 상위 타입에서 지정한 리턴 값의 범위에 해당되지 않는 값을 리턴하는 것

#### 리스코프 치환 원칙은 계약과 확장에 대한 것

기능 실행의 계약과 관련해서 흔히 발생하는 위반 사례로는 다음과 같은 것이 있다.
- 명시된 명세에서 벗어난 값을 리턴한다.
- 명시된 명세에서 벗어난 익셉션을 발생시킨다.
- 명시된 명세에서 벗어난 기능을 수행한다.

리스코프 치환 원칙이 지켜지지 않으면 개방 폐쇄 원칙을 지킬 수 없게 된다.
개방 폐쇄 원칙을 지키지 않으면 기능 확장을 위해 더 많은 부분을 수정해야 하므로, 기능을 확장하기가 어렵게 된다.

### 인터페이스 분리 원칙(Interface segregation principle)

> 인터페이스는 그 인터페이스를 사용하는 클라이언트를 기준으로 분리해야 한다.

원래의 정의는
> 클라이언트는 자신이 사용하는 메서드에만 의존해야 한다.

클라이언트 입장에서 사용하는 기능만 제공하도록 인터페이스를 분리함으로써 한 기능에 대한 변경의 여파를 최소화할 수 있게 된다.
또한, 단일 책임 원칙이 잘 지켜질 때 인터페이스와 콘크리트 클래스의 재사용 가능성을 높일 수 있으므로 인터페이스 분리 원칙은 결국 인터페이스와 콘크리트 클래스의 재사용성을 높여주는 효과도 갖는다.

#### 인터페이스 분리 원칙은 클라이언트에 대한 것

인터페이스가 분리되는 기준은 클라이언트가 되어야 한다.

### 의존 역전 원칙(Dependency inversion principle)

> 고수준 모듈은 저수준 모듈의 구현에 의존해서는 안 된다. 저수준 모듈이 고수준 모듈에서 정의한 추상 타입에 의존해야 한다.

#### 고수준 모듈이 저수준 모듈에 의존할 때의 문제

고수준 모듈은 상대적으로 큰 틀(즉, 상위 수준)에서 프로그램을 다룬다면, 저수준 모듈은 각 개별 요소(즉, 상세)가 어떻게 구현될지에 대해서 다룬다.
프로젝트 초기의 요구사항이 어느 정도 안정화되면 이후부터는 상세 수준에서의 변경이 발생할 가능성이 높아진다.

#### 의존 역전 원칙을 통한 변경의 유연함 확보

답은 추상화.

리스코프 치환 원칙과 함께 개발 폐쇄 원칙을 따르는 설계를 만들어 주는 기반이 된다.

#### 소스 코드 의존과 런타임 의존

의존 역전 원칙은 소스 코드에서의 의존을 역전시키는 원칙.

```java
public class FileDataReader implements ByteSource{
    // ...
}
```
ByteSource 인터페이스는 저수준 모듈보다는 고수준 모듈인 FlowController 입장에서 만들어지는데, 이것은 고수준 모듈이 저수준 모듈에 의존했던 상황이 역전되어, 저수준 모듈이 고수준 모듈에 의존하게 된다는 것을 의미한다.

소스 코드 상에서의 의존은 역전되었지만 런타임에서의 의존은 고수준 모듈의 객체에서 저수준 모듈의 객체로 향한다.

## SOLID 논쟁

Allen Holub(@allenholub)의 트윗
https://twitter.com/allenholub/status/1373342622576562177

[이규원님 포스트](https://www.facebook.com/100000996971569/posts/3889488941094300)에서 공유된 글

> "해외도 국내도 SOLID가 태초에 신이 내린 원칙인 것처럼 받아들이는 사람들이 많았죠...여튼 SOLID는 수많은 설계 지침 중 엉클밥과 마이클 페더스가 5개를 모아본 것 뿐이고 목적이 아니라 도구라는 점, 그리고 도구는 쓸모있을 때와 그렇지 않을 때가 있다는 것을 많은 사람들이 이해하면 좋겠습니다."

Allen Holub는 Open/Closed 원칙이 가장 민첩함(agility)을 방해하는 요소라고 주장.
Dan이 말하는 "no bigger than your head" 원칙 또한 불필요한 복잡성을 가져올 수 있고, 코드가 매우 단순하면 수정이 쉽다고 합니다. "open"은 단지 불필요한 복잡성이라고.

### Dan North(Daniel Terhorst-North)의 글

[Dan이 어딘가에서 발표한 자료](https://speakerdeck.com/tastapod/why-every-element-of-solid-is-wrong)때문에 많은 비난을 받고 있었고, 왜 그렇게 생각했는지 정리한 글입니다.

https://dannorth.net/2021/03/16/cupid-the-back-story/

발표자료는 (발표된 장소와 상황 때문인지) 비교적 거칠지만, 이를 설명하기 위한 이 글에서 자세히 설명합니다.

결국 코드를 단순하게 만드는 것이 SOLID의 각 원칙의 대안이 될 수 있다고 설명합니다. YAGNI 관점에서 각 원칙이 지나치게 복잡성을 유도한다고 말이죠. SOLID는 원칙이 아닌 패턴이라고 설명합니다. 원칙이란 일반적으로 유용한 조언이 되어야 하는데, SOLID는 그렇지 않다고 합니다.

> A pattern is a strategy that works in a given context (God class) that has benefits (smaller components) and trade-offs (more separate things to manage).
- 패턴이란 혜택과 트래이드오프를 가진 주어진 컨텍스트에서 작동하는 전략입니다.  

엉클 밥도 Dan의 발표자료에 대해 이야기 한 적이 있습니다. 물론 Dan이 이 글을 쓰기 전이긴 합니다.
https://blog.cleancoder.com/uncle-bob/2020/10/18/Solid-Relevance.html

구글 번역의 힘을 빌려 대략의 내용을 옮겨보면,

SRP ) 단일 책임 원칙.
- SRP에 대한 그의 대답은 "Write Simple Code"입니다. 나는 동의한다. SRP는 코드를 단순하게 유지하는 방법 중 하나입니다.

OCP ) 개방-폐쇄 원칙.
- Dan은 요구 사항이 변경되면 기존 코드가 잘못됐다고 이야기 하지만, 요구 사항이 변경되면 기존 코드의 **일부만** 잘못되었습니다. 기존 코드의 대부분은 여전히 ​​옳습니다. 그리고 우리는 잘못된 코드가 다시 작동하도록 만들기 위해 올바른 코드를 변경할 필요가 없도록하고 싶습니다. Dan의 대답은 "간단한 코드 작성"입니다. 다시 한 번 동의합니다. 그리고 아이러니하게도 그는 옳습니다. 간단한 코드는 열려 있고 닫혀 있습니다.

LSP ) Liskov 대체 원칙.
- 이 원칙은 추상화를 선명하고 명확하게 유지하는 것입니다. 이것이 구식 개념이라고 믿기는 불가능합니다. Dan의 슬라이드는이 주제에 대해 완전히 정확합니다. 그는 단순히 원칙의 요점을 놓쳤습니다. 단순 코드는 명확한 하위 유형 관계를 유지하는 코드입니다.

ISP ) 인터페이스 분리 원칙.
- Dan의 마지막 요점은 괜찮습니다. 예를 들어, 두 개의 인터페이스가있는 클래스를 두 개의 개별 클래스로 분할 할 수 있다면 그렇게하는 것이 좋습니다 (SRP). 그러나 그러한 분리는 종종 가능하지도 않고 바람직하지도 않습니다.

DIP ) 종속성 반전 원리.
- 우리는 낮은 수준의 세부 사항에서 높은 수준의 추상화를 분리하고자합니다. 이러한 분리는 모든 소스 코드 종속성, 특히 아키텍처 경계를 넘는 종속성이 낮은 수준의 세부 정보가 아닌 높은 수준의 추상화를 가리 키도록 시스템 내의 종속성을 신중하게 관리함으로써 달성됩니다.

결론
- SOLID는 복잡도만 올리니 그냥 간단하게만 작성해! VS SOLID는 코드를 간단하게 작성하고 이해하기 위한 원칙이야!
